package com.user.user_profile_service.service;

import com.user.user_profile_service.dto.UserTransactionDto;
import com.user.user_profile_service.external.banking.simulation.ExternalBankingFacade;
import com.user.user_profile_service.external.banking.simulation.ExternalPaymentResponse;
import com.user.user_profile_service.model.*;
import com.user.user_profile_service.repository.PaymentRepositoryFacade;
import com.user.user_profile_service.repository.model.PaymentTransactionDbEntity;
import com.user.user_profile_service.utils.PaymentsMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.Comparator;
import java.util.List;

import static com.user.user_profile_service.model.TransactionStatus.INITIATED;
import static reactor.core.publisher.Mono.just;

@Slf4j
@Service
@RequiredArgsConstructor
public class PaymentService {

    private final PaymentRepositoryFacade paymentRepositoryFacade;

    private final ExternalBankingFacade externalBankingFacade;

    private final int MAX_TRANSACTION_COUNT = 10;

    public Mono<UserBalance> getUserBalance(String iban) {
        return externalBankingFacade.getUserBalance(iban);
    }

    public Mono<List<UserTransaction>> getUserTransactions(String iban) {
        return externalBankingFacade.getUserTransactions(iban)
                .flatMapMany(Flux::fromIterable)
                .switchIfEmpty(Mono.error(new IllegalArgumentException("There are no recent transactions for account id: " + iban)))
                .sort(byUserTransaction())
                .take(MAX_TRANSACTION_COUNT)
                .map(PaymentsMapper::fromUserTransactionDto)
                .collectList();
    }

    public Mono<PaymentResponse> initiatePayment(PaymentRequest request) {
        // Ensure use have enough amount on balance
        return externalBankingFacade.getUserBalance(request.getDebtorAccount())
                .filter(balance -> userHasEnoughBalanceAmount(balance, request))
                .switchIfEmpty(Mono.error(
                        new IllegalArgumentException("There is not enough money on balance of account: " + request.getDebtorAccount())
                ))
                // Payments should be stored in the local database BEFORE being sent to the external API
                .then(paymentRepositoryFacade.saveTransaction(initialPaymentPreparation(request)))
                .map(PaymentsMapper::toExternalPaymentRequest)
                // Initiate payment
                .flatMap(externalBankingFacade::initiatePayment)
                .flatMap(this::postPaymentUpdate);
    }

    private PaymentTransactionDbEntity initialPaymentPreparation(PaymentRequest request) {
        return PaymentTransactionDbEntity.builder()
                .transactionId(null) // should be autogenerated in database
                .status(INITIATED.toString())
                .debtorAccount(request.getDebtorAccount())
                .creditorAccount(request.getCreditorAccount())
                .amount(request.getAmount())
                .currency(request.getCurrency().toString())
                .timestampMs(System.currentTimeMillis())
                .build();
    }

    private Mono<PaymentResponse> postPaymentUpdate(ExternalPaymentResponse response) {
        return paymentRepositoryFacade.findTransaction(response.transactionId())
                .map(entity -> entity.withStatus(response.status()))
                .flatMap(paymentRepositoryFacade::saveTransaction)
                .then(just(response))
                .map(this::toPaymentResponse);
    }

    private PaymentResponse toPaymentResponse(ExternalPaymentResponse response) {
        return new PaymentResponse(response.transactionId(), response.status(), response.message());
    }

    private Comparator<UserTransactionDto> byUserTransaction() {
        return Comparator
                .comparingLong(UserTransactionDto::getTimestampMs).reversed();
    }

    private boolean userHasEnoughBalanceAmount(UserBalance balance, PaymentRequest request) {
        if (balance == null) return false;
        if (balance.getAmount() == null) {
            log.error("Balance amount is null");
            throw new IllegalArgumentException("Balance amount is absent");
        }
        Currency currency = balance.getCurrency();
        if (currency == null || !currency.equals(request.getCurrency())) {
            log.error("Currencies are not equal: actual " + currency + ", requested " + request.getCurrency());
            throw new IllegalArgumentException("Incorrect account currency. Available: " + currency);
        }
        return balance.getAmount().compareTo(request.getAmount()) >= 0;
    }
}